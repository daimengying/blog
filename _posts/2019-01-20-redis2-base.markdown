---
layout: post
title:  "redis过期策略和淘汰机制"
categories: redis
tags: Java高阶面试
author: mydai
description: redis原理剖析（三）：redis过期策略和淘汰机制
---
### 一、redis过期策略
**定期删除+惰性删除**<br/><br/>
定期删除，指的是redis默认是每隔100ms就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。假设redis里放了10万个key，都设置了过期时间，你每隔几百毫秒，就检查10万个key，那redis基本上就死了，cpu负载会很高的，消耗在你的检查过期key上了。注意，这里可不是每隔100ms就遍历所有的设置过期时间的key，那样就是一场性能上的灾难。实际上redis是每隔100ms随机抽取一些key来检查和删除的。<br/><br/>
但是问题是，定期删除可能会导致很多过期key到了时间并没有被删除掉，那咋整呢？所以就是惰性删除了。这就是说，在你获取某个key的时候，redis会检查一下 ，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除，不会给你返回任何东西。<br/><br/>
并不是key到时间就被删除掉，而是你查询这个key的时候，redis再懒惰的检查一下。通过上述两种手段结合起来，保证过期的key一定会被干掉。<br/><br/>
很简单，就是说，你的过期key，靠定期删除没有被删除掉，还停留在内存里，占用着你的内存呢，除非你的系统去查一下那个key，才会被redis给删除掉。<br/><br/>
但是实际上这还是有问题的，如果定期删除漏掉了很多过期key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期key堆积在内存里，导致redis内存块耗尽了，咋整？答案是：走内存淘汰机制。


### 二、内存淘汰
**noeviction：** 当内存不足以容纳新写入数据时，新写入操作会报错，基本不会用这个<br/>
**allkeys-lru：** 当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）<br/>
**allkeys-random：** 当内存不足以容纳新写入数据时，在键空间中，随机移除某个key，这个一般没人用<br/>
**volatile-lru：** 当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key（这个一般不太合适）<br/>
**volatile-random：** 当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key<br/>
**volatile-ttl：** 当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除<br/>