---
layout: post
title:  "数据库与缓存双写不一致问题"
categories: redis
tags: Java高阶面试
author: mydai
description: redis原理剖析（七）：高并发下数据库与缓存双写不一致问题场景分析和解决方案
---

### 一、最初级的缓存不一致问题以及解决方案
问题：先修改数据库，再删除缓存，如果删除缓存失败了，那么会导致数据库中是新数据，缓存中是旧数据，数据出现不一致<br/>
**解决思路：**
先删除缓存，再修改数据库，如果删除缓存成功了，如果修改数据库失败了，那么数据库中是旧数据，缓存中是空的，那么数据不会不一致<br/>

### 二、比较复杂的数据不一致问题分析
问题：数据发生了变更，先删除了缓存，然后要去修改数据库，此时还没修改，一个请求过来，去读缓存，发现缓存空了，去查询数据库，查到了修改前的旧数据，放到了缓存中，而数据变更的程序完成了数据库的修改，完了，数据库和缓存中的数据不一样了。。。。<br/>
**解决方案：**<br/>
更新数据的时候，根据数据的唯一标识，将操作路由之后，发送到一个jvm内部的队列中<br/>
读取数据的时候，如果发现数据不在缓存中，那么将重新读取数据+更新缓存的操作，根据唯一标识路由之后，也发送同一个jvm内部的队列中<br/>
一个队列对应一个工作线程<br/>
每个工作线程串行拿到对应的操作，然后一条一条的执行<br/>
这样的话，一个数据变更的操作，先执行，删除缓存，然后再去更新数据库，但是还没完成更新<br/>
此时如果一个读请求过来，读到了空的缓存，那么可以先将缓存更新的请求发送到队列中，此时会在队列中积压，然后同步等待缓存更新完成<br/>
这里有一个优化点，一个队列中，其实多个更新缓存请求串在一起是没意义的，因此可以做过滤，如果发现队列中已经有一个更新缓存的请求了，那么就不用再放个更新请求操作进去了，直接等待前面的更新操作请求完成即可<br/>
待那个队列对应的工作线程完成了上一个操作的数据库的修改之后，才会去执行下一个操作，也就是缓存更新的操作，此时会从数据库中读取最新的值，然后写入缓存中<br/>
如果请求还在等待时间范围内，不断轮询发现可以取到值了，那么就直接返回;<br/> 如果请求等待的时间超过一定时长，那么这一次直接从数据库中读取当前的旧值<br/>

<html>
	<img src="{{ site.baseurl}}/assets/images/post_imgs/复杂的数据库+缓存双写一致保障方案.png"  />
</html>

